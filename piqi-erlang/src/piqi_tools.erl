%% Copyright 2009, 2010, 2011 Anton Lavrik
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.

%%
%% @doc Erlang bindings for Piqi tools
%%
%% This module contains Erlang binding for some of Piqi tools functions such as
%% "piqi convert". It is implemented as a gen_server that communicates with Piqi
%% tools server ("piqi server") via Erlang port interface.
%%
-module(piqi_tools).

-behavior(gen_server).


% TODO: tests, edoc


-export([start_link/0, start/0, stop/0]).
% API
-export([add_piqi/1, convert/4, convert/5, ping/0]).
% gen_server callbacks
-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).
% used by gen_server2
-export([prioritise_info/2]).


-include("piqirun.hrl").

% type definitions generated by piqic
-include("piqi_rpc_piqi.hrl").
-include("piqi_tools_piqi.hrl").


%
% Static configuration section
%

% Uncomment to use gen_server2 instead of gen_server. In case of many concurrent
% requests, gen_server2 provides low call latencies and maitains a minimal
% message queue by reading and processing Port responses as soon as they arrive.
% In contrast, gen_server processes Port responses in the order of their
% arrival, which may be after all the call requests that are already sitting in
% the message queue. Because of that, for gen_server, request pipelining is
% configured statically by "MAX_PIPELINE_SIZE" macro (see below).

%-define(USE_GEN_SERVER2, 1).


% This variable controls maximum pipeline size. When the maximum pipeline size
% is reached, piqi_tools will start explicitly receiving responses from the port
% before sending more requests.
%
% This option is used only for gen_server and doesn't have any effect in case of
% the USE_GEN_SERVER2 is defined. In case
%
% XXX: is it possible to calculate optimal max pipeline size dynamically?
-ifndef(USE_GEN_SERVER2).
-define(MAX_PIPELINE_SIZE, 10).
-endif.


% Uncommend to enable collection of some debug info accessible via
% sys:get_status(piqi_tools).

%-define(DEBUG, 1).

%
% End of static configuration section
%


-ifdef(DEBUG).
-include("debug.hrl").

debug_init() ->
    put(queue_len, 0),
    put(max_queue_len, 0).

debug_enqueue() ->
    S = get(queue_len) + 1,
    put(queue_len, S),
    %io:put_chars("incr: " ++ integer_to_list(S) ++ "\n"),
    put(max_queue_len, max(S, get(max_queue_len))).

debug_dequeue() ->
    S = get(queue_len) - 1,
    %io:put_chars("decr: " ++ integer_to_list(S) ++ "\n"),
    put(queue_len, S).

-define(DEBUG_INIT, debug_init()).
-define(DEBUG_ENQUEUE, debug_enqueue()).
-define(DEBUG_DEQUEUE, debug_dequeue()).

-else.
-define(DEBUG_INIT, ok).
-define(DEBUG_ENQUEUE, ok).
-define(DEBUG_DEQUEUE, ok).
-endif.


% which gen_server variant to use: gen_server or gen_server2?
-ifndef(USE_GEN_SERVER2).
-define(GEN_SERVER, gen_server).
-else.
-define(GEN_SERVER, gen_server2).
-endif.


% gen_server name
-define(SERVER, ?MODULE).


% gen_server:call timeout
-ifndef(DEBUG).
-define(CALL_TIMEOUT, 5000).
-else.
-define(CALL_TIMEOUT, infinity).
-endif.


% Options for "piqi server" port command
-ifndef(DEBUG).
-define(PIQI_FLAGS, "").
-else.
-define(PIQI_FLAGS, " --no-warnings"). % XXX: --trace
-endif.


-define(PIQI_TOOLS_ERROR, 'piqi_tools_error').


% gen_server state
-record(state, {
    % Erlang port id
    port :: port(),

    % data remaining from the previous packet received from the port
    prev_data = <<>> :: binary(),

    % queue of gen_server Clients or request continuations
    queue = queue:new() :: any(),

    % queue length
    queue_len = 0 :: non_neg_integer()
}).


%
% starting gen_server
%

start_link() ->
    start_common(start_link).


% independent start -- not as a part of OTP supervision tree
start() ->
    start_common(start).


start_common(StartFun) ->
    ?GEN_SERVER:StartFun({local, ?SERVER}, ?MODULE, [], []).


% manual stop (when started by start/0 *)
stop() ->
    ?GEN_SERVER:cast(?SERVER, stop).


%
% gen_server callbacks
%

% used only by gen_server2: receive responses and EXIT's from the Port before
% all other calls and casts
prioritise_info(_, _) -> 1.


%% @private
init([]) ->
    erlang:process_flag(trap_exit, true),
    Command = "piqi server" ++ ?PIQI_FLAGS,
    %Command = "tee ilog | piqi server --trace | tee olog",

    % TODO: handle initialization error and report it as {error, Error} tuple
    % TODO, XXX: on error, sleep for a while to prevent an immediate restart
    % attempt
    % XXX: use {spawn_executable, Command} instead to avoid shell's error
    % messages printed on stderr?
    Port = erlang:open_port({spawn, Command}, [stream, binary]), % exit_status?
    State = #state{ port = Port },
    ?DEBUG_INIT,
    {ok, State}.


%% @private
handle_call({rpc, PiqiMod, Name, ArgsData}, From, State) ->
    NewState = rpc_call(PiqiMod, Name, ArgsData, From, State),
    {noreply, NewState}.


%% @private user-initiated stop
handle_cast(stop, State) ->
    {stop, normal, State}; 

handle_cast(_Msg, State) ->
    % XXX
    {noreply, State}.


% packet from the "piqi server" Port
handle_info({Port, {data, Data}}, State = #state{port = Port}) ->
    NewState = handle_rpc_response(Data, State),
    {noreply, NewState};

% Port command has exited
handle_info({'EXIT', Port, Reason}, State = #state{port = Port}) ->
    StopReason = {?PIQI_TOOLS_ERROR, {'port_command_exited', Reason}},
    {stop, StopReason, State};

% XXX: no process should link this gen_server except piqi_sup
%handle_info({'EXIT', _Port, _Reason}, State) ->
%    % EXIT from a linked process, just ignoring it
%    {noreply, State};

handle_info(Info, State) ->
    % XXX: log a message
    erlang:port_close(State#state.port),
    StopReason = {?PIQI_TOOLS_ERROR, {'unexpected_message', Info}},
    {stop, StopReason, State}.


%% @private
terminate(_Reason, State) ->
    % don't bother checking if the port is still valid, e.g. after EXIT
    catch erlang:port_close(State#state.port),
    ok.


%% @private
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.


% do the actual rpc call
rpc_call(PiqiMod, Name, ArgsData, From, State) ->
    % NOTE: using process dictionary as a fast SET container to check whether
    % type information from this module has been added to the piqi server
    case PiqiMod =:= 'undefined' orelse get(PiqiMod) =:= 'add_piqi' of
        true ->
            % type information is either not required or has been added already
            % => just make the rpc call
            NewState = do_rpc_call(Name, ArgsData, From, State),
            receive_rpc_response(NewState);

        false ->
            % add type information to the Piqi server from the module before
            % calling the actual server function

            % XXX: check if the function is exported?
            BinPiqiList = PiqiMod:piqi(),

            % memorize that we've added type information for this module (well,
            % we haven't but it is better than implementing some kind of
            % blocking for subsequent rpc calls while this request is
            % executing). If there's any problem with add_piqi, the gen_server
            % will crash when it receives unsuccessful response form the Port.
            erlang:put(PiqiMod, 'add_piqi'),

            RealCall = fun (State0) -> do_rpc_call(Name, ArgsData, From, State0) end,

            % add type information from the PiqiMod to the Piqi-tools server
            _NewState = add_piqi_local(BinPiqiList, RealCall, State)
    end.


do_rpc_call(Name, ArgsData, From, State) ->
    send_rpc_request(State#state.port, Name, ArgsData),
    % add the Caller to the queue
    NewQueue = queue:in(From, State#state.queue),
    NewQueueLen = State#state.queue_len + 1,
    ?DEBUG_ENQUEUE,
    State#state{ queue = NewQueue, queue_len = NewQueueLen }.


handle_rpc_response(NewData, State) ->
    PrevData = State#state.prev_data,
    Data =
        case PrevData =:= <<>> of
            true -> NewData;
            _ when NewData =:= <<>> -> PrevData;
            _ -> <<PrevData/binary, NewData/binary>>
        end,
    try
        {Packet, Rest} = piqirun:parse_block(Data),
        Response = piqi_rpc_piqi:parse_response(Packet),

        % queue entries are either Pids or Funs
        {{value, ClientOrCont}, NewQueue} = queue:out(State#state.queue),
        NewQueueLen = State#state.queue_len - 1,
        ?DEBUG_DEQUEUE,

        NewState = State#state{
            prev_data = Rest,
            queue = NewQueue, queue_len = NewQueueLen
        },

        NewState_1 =
            case ClientOrCont of
                Fun when is_function(Fun) -> % continuation
                    Fun(Response, NewState);
                Client ->
                    ?GEN_SERVER:reply(Client, Response),
                    NewState
            end,

        case Rest =:= <<>> of
            true -> NewState_1;
            _ ->
                % try to read another response from the data we've received
                handle_rpc_response(<<>>, NewState_1)
        end
    catch
        {'piqirun_error', 'not_enough_data'} ->
            % receive the next portion if there's not enough data in this
            % message
            State#state{ prev_data = Data }
    end.


%
% Piqi-RPC request/response
%

% @hidden send a Piqi-RPC request
send_rpc_request(Port, Name, ArgsData) ->
    Request = #piqi_rpc_request{ name = Name, data = ArgsData },
    Data = piqi_rpc_piqi:gen_request(Request),
    send_rpc_packet(Port, Data).


-ifdef(USE_GEN_SERVER2).
% When we use gen_server2, responses from the port are received through the
% gen_server2 receive loop and handle_info() function. They are also prioretized
% to be received before all calls and casts that may be sitting in the queue.
receive_rpc_response(State) -> State.
-else.
receive_rpc_response(State) when State#state.queue_len < ?MAX_PIPELINE_SIZE ->
    % we can send more requests before receiving responses
    State;
receive_rpc_response(State = #state{port = Port}) ->
    receive
        {Port, {data, Data}} ->
            handle_rpc_response(Data, State);
        {'EXIT', Port, Reason} ->
            StopReason = {?PIQI_TOOLS_ERROR, {'port_command_exited', Reason}},
            exit(StopReason)
    end.
-endif.


% @hidden send a Piqi-RPC packet
send_rpc_packet(Port, Data) ->
    Packet = piqirun:gen_block(Data),
    % NOTE: this is a blocking call. If the port is busy, the process will be
    % suspended until the port becomes available.
    true = erlang:port_command(Port, Packet).

    % XXX: testing has proven that use of non-blocking version doesn't give any
    % benefits. The hypothesis was that, when if we use gen_server2, instead of
    % blocking we can do something useful, such as receive and process responses
    % and in the meantime keep trying to resend the port command. It turns out
    % that this is fruitless, because instead of processing responses we are
    % burning CPU cicles trying to re-send port_command (we did that by passing
    % the port command through our own even loop)
    %
    % erlang:port_command(Port, Packet, [nosuspend]) -> true | false


%
% API implementation
%

-spec rpc/3 :: (
    PiqiMod :: 'undefined' | atom(),
    Name :: binary() | string(),
    ArgsData :: 'undefined' | iodata() ) -> piqi_rpc_response().

% make an RPC call for function name "Name" and Protobuf-encoded arguments
% "ArgsData". "PiqiMod" is the name of the Erlang module that was generated by
% "piqic erlang". This module must contain type information for the function
% arguments.
%
rpc(PiqiMod, Name, ArgsData) ->
    BinData =
        case ArgsData of
            'undefined' -> 'undefined';
            _ -> iolist_to_binary(ArgsData)
        end,
    call_server({rpc, PiqiMod, Name, BinData}).


-spec rpc/2 :: (
    Name :: binary() | string(),
    ArgsData :: 'undefined' | iodata() ) -> piqi_rpc_response().

% make an RPC call of function "Name" and Protobuf-encoded arguments
% "ArgsData"
rpc(Name, ArgsData) ->
    rpc(_PiqiMod = 'undefined', Name, ArgsData).


-spec rpc/1 :: ( Name :: binary() | string() ) -> piqi_rpc_response().

% make an RPC call of function "Name" that doesn't have input parameters
rpc(Name) ->
    rpc(Name, _ArgsData = 'undefined').


% XXX: use timeout?
call_server(Args) ->
    % XXX: High-availability setup, allowing the gen_server to restart quickly
    % without failing the calls. This might be useful for "piqi server" upgrades
    % and in case of potential "piqi server" crashes.
    try
        ?GEN_SERVER:call(?SERVER, Args, ?CALL_TIMEOUT)
    catch
        % Piqi tools has exited, but hasn't been restarted by Piqi supervisor
        % yet
        exit:{noproc, _} ->
            piqi_sup:restart_piqi_tools_child(),
            ?GEN_SERVER:call(?SERVER, Args, ?CALL_TIMEOUT)
    end.


-spec ping/0 :: () -> ok.

% a simple service livecheck function
ping() ->
    rpc(<<"ping">>).


-spec add_piqi/1 :: (BinPiqiList :: [binary()]) -> ok | {error, string()}.

% add a Protobuf-encoded Piqi module specifications to Piqi tools. Added types
% will be used later by "convert" and other functions.
add_piqi(BinPiqiList) ->
    BinInput = encode_add_piqi_input(BinPiqiList),
    % send request to the gen_server
    Output = rpc(<<"add-piqi">>, BinInput),
    decode_add_piqi_output(Output).


add_piqi_local(BinPiqiList, RealCall, State) ->
    BinInput = encode_add_piqi_input(BinPiqiList),
    % send add_piqi RPC request to the Port putting the continuation function in
    % the queue instead of the caller's Pid
    Continuation =
        fun (Response, State0) ->
            % XXX: don't handle errors, assuming that this call is safe since
            % we've added these Piqi modules before without a problem
            ok = decode_add_piqi_output(Response),
            % execute the original request
            RealCall(State0)
        end,
    _NewState = do_rpc_call(<<"add-piqi">>, BinInput, Continuation, State).


encode_add_piqi_input(BinPiqiList) ->
    Input = #piqi_tools_add_piqi_input{
        format = 'pb',
        data = BinPiqiList
    },
    BinInput = piqi_tools_piqi:gen_add_piqi_input(Input),
    iolist_to_binary(BinInput).


decode_add_piqi_output(Output) ->
    case Output of
        ok -> ok;
        {error, BinError} ->
            Error = piqi_tools_piqi:parse_add_piqi_error(BinError),
            % NOTE: parsed strings are represented as binaries
            {error, binary_to_list(Error)};
        X ->
            handle_common_result(X)
    end.


-spec convert/5 :: (
    PiqiMod :: 'undefined' | atom(), % Erlang module generated by "piqic erlang"
    TypeName :: string() | binary(),
    InputFormat :: piqi_tools_format(),
    OutputFormat :: piqi_tools_format(),
    Data :: binary() ) -> {ok, Data :: binary()} | {error, string()}.

% convert `Data` of type `TypeName` from `InputFormat` to `OutputFormat`
convert(PiqiMod, TypeName, InputFormat, OutputFormat, Data) ->
    Input = #piqi_tools_convert_input{
        type_name = TypeName,
        input_format = InputFormat,
        output_format = OutputFormat,
        data = Data
    },
    BinInput = piqi_tools_piqi:gen_convert_input(Input),
    case rpc(PiqiMod, <<"convert">>, BinInput) of
        {ok, BinOutput} ->
            Output = piqi_tools_piqi:parse_convert_output(BinOutput),
            Res = Output#piqi_tools_convert_output.data,
            {ok, Res};
        {error, BinError} ->
            Error = piqi_tools_piqi:parse_convert_error(BinError),
            % NOTE: parsed strings are represented as binaries
            {error, binary_to_list(Error)};
        X ->
            handle_common_result(X)
    end.


-spec convert/4 :: (
    TypeName :: string() | binary(),
    InputFormat :: piqi_tools_format(),
    OutputFormat :: piqi_tools_format(),
    Data :: binary() ) -> {ok, Data :: binary()} | {error, string()}.

% convert `Data` of type `TypeName` from `InputFormat` to `OutputFormat`
convert(TypeName, InputFormat, OutputFormat, Data) ->
    convert('undefined', TypeName, InputFormat, OutputFormat, Data).


handle_common_result({rpc_error, _} = X) ->
    % recoverable protocol-level error
    throw({?PIQI_TOOLS_ERROR, X}).

